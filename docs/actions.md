# Actions

Actions are Misk's unit for an endpoint. Misk lets you make HTTP actions, and gRPC actions via 
[Wire](https://github.com/square/wire).

## Web Actions

Below are some example Web action declarations. Note that many of the annotations are optional.

GET:

```kotlin
@Singleton
class HelloWebAction @Inject constructor() : WebAction {
  @Get("/hello/{name}") // Enclose path parameters in {}
  @ResponseContentType(MediaTypes.APPLICATION_JSON)
  @Authenticated(services = ["my-other-app"], capabilities = ["my-app_owners"])
  fun hello(
    // Use @PathParam with the name of the param. Required if there's a param in the path pattern.
    @PathParam name: String,
    // RequestHeaders is optional:
    @RequestHeaders headers: Headers,
    // QueryParams are optional:
    @QueryParam nickName: String?, // e.g. /hello/abc?nickName=def
    @QueryParam greetings: List<String>? // e.g. /hello/abc?greetings=def&greetings=ghi
  ): HelloResponse {
    return HelloResponse(name)
  }
}
```

POST:

```kotlin
@Singleton
class HelloWebPostAction @Inject constructor() : WebAction {
  @Post("/hello/{name}")
  @RequestContentType(MediaTypes.APPLICATION_JSON)
  @ResponseContentType(MediaTypes.APPLICATION_JSON)
  @Authenticated(services = ["my-other-app"], capabilities = ["my-app_owners"])
  fun hello(
      @PathParam name: String, 
      // RequestBody is optional, and is automatically deserialized to the provided type.
      @RequestBody body: PostBody
  ): HelloPostResponse {
    return HelloPostResponse(body.greeting, name)
  }
}

data class HelloPostResponse(val greeting: String, val name: String)

data class PostBody(val greeting: String)
```

### Setting up HTTP actions

Install the action into a module:
```kotlin
class HelloModule : KAbstractModule() {
  override fun configure() {
    install(WebActionModule.create<HelloWebAction>())
    install(WebActionModule.create<HelloWebPostAction>())
  }
}
```

And then put that module onto the top level `MiskApplication`.
```kotlin
fun main(args: Array<String>) {
  MiskApplication(
    // ...
    HelloModule(), // new!
  ).run(args)
}
```

### Testing HTTP responses

In your testing module configuration, add this:
```kotlin
 override fun configure(){
    install(WebServerTestingModule())
 }
```

### Response type

If you change the action's response type to `Response<T>`, it gives you better control over the 
response status code and headers.

```kotlin
@Singleton
class HelloWebResponseAction @Inject constructor() : WebAction {
  @Get("/hello_but_203/{name}")
  @ResponseContentType(MediaTypes.APPLICATION_JSON)
  fun hello(@PathParam name: String): Response<HelloResponse> = Response(
    statusCode = 203,
    headers = headersOf(),
    body = HelloResponse()
  )
}
```

It's also possible to throw exceptions that are mapped to status codes.

```kotlin
@Singleton
class HelloWebResponseAction @Inject constructor() : WebAction {
  @Get("/no_access/{name}")
  fun hello(@PathParam name: String): HelloResponse {
      throw UnauthenticatedException()
  }
}
```

## gRPC Actions

Misk has support for gRPC actions via the [Wire](https://github.com/square/wire) protocol buffer
(protobuf) library.

To create a gRPC action, first define the relevant protos for your service. Let’s say we’re 
creating a `GreeterService` that exposes one API, `Hello`. Create this file in 
`src/main/proto/hello.proto`:

```protobuf
syntax = "proto2";
package squareup.cash.hello;

option java_package = "com.squareup.protos.cash.hello";

message HelloRequest {
  optional string message = 1;
}

message HelloResponse {
  optional string message = 1;
}

service GreeterService {
  rpc Hello(HelloRequest) returns (HelloResponse) {}
}
```

Next, in your project's build file (for this example, `build.gradle.kts`), add a dependency on the 
wire plugin:

```kt
plugins {
  id("com.squareup.wire")
}
```

Add the following configuration to generate the gRPC interfaces for your service:

```kt
wire {
  sourcePath {
    srcDir("src/main/proto")
  }

  kotlin {
    include("squareup.cash.hello.GreeterService")
    rpcCallStyle = "blocking"
    rpcRole = "server"
    singleMethodServices = true
  }

  java {
  }
}
```

Finally, implement and bind your gRPC action. `GreeterServiceHelloBlockingServer` is generated by
Wire.

```kotlin
@Singleton
class HelloGrpcAction @Inject internal constructor()
  : GreeterServiceHelloBlockingServer, WebAction {

  @Unauthorized
  override fun Hello(request: HelloRequest): HelloResponse {
    return HelloResponse("message")
  }
}

// This module binds HelloGrpcAction.
class GreeterActionModule : KAbstractModule() {
  override fun configure() {
    install(WebActionModule.create<HelloGrpcAction>())
  }
}
```

Creating a gRPC action automatically creates a JSON endpoint with all of the same annotations in the 
path defined by the `...BlockingServer`, typically `/<package>.<service name>/<rpc name>`.

You can also create a second class that extends WebAction to customize this further. Read more about 
HTTP actions in [Web Actions](#web-actions). If you're building both a gRPC and a HTTP action, a 
common pattern is to have them both use a common dependency:

```kotlin
@Singleton
class HelloGrpcAction @Inject constructor(val greeter: Greeter)
  : GreeterServiceHelloBlockingServer, WebAction {
  @Unauthorized override fun hello() = HelloResponse(greeter.greet())
}

@Singleton
class HelloWebAction @Inject constructor(val greeter: Greeter) : WebAction {
  @Unauthorized
  @Get("/hello")
  @ResponseContentType(MediaTypes.APPLICATION_JSON)
  fun hello() = HelloResponse(greeter.greet())
}

@Singleton
class Greeter @Inject constructor()  {
  fun greet() = "Hello world"
}
```

## ActionScoped

`ActionScoped` gives an action access to context produced by the action's interceptors.

Misk has a few `ActionScoped` items built in:

* [`MiskCaller`](0.x/misk-actions/misk/-misk-caller/index.md) - access derived authorization details
* [`HttpCall`](0.x/misk/misk.web/-http-call/index.md) - access lower level HTTP details, e.g. 
  request headers
