// Manually rewrote @hotwired/stimulus to /static/cache/stimulus/3.1.0/stimulus.min.js
import{Controller as e}from"/static/cache/stimulus/3.1.0/stimulus.min.js";let method=(e,t)=>{let s=e[t];return"function"==typeof s?s:(...e)=>{}},composeEventName=(e,t,s)=>{let i=e;return!0===s?i=`${t.identifier}:${e}`:"string"==typeof s&&(i=`${s}:${e}`),i},extendedEvent=(e,t,s)=>{let{bubbles:i,cancelable:n,composed:o}=t||{bubbles:!0,cancelable:!0,composed:!0};t&&Object.assign(s,{originalEvent:t});let r=new CustomEvent(e,{bubbles:i,cancelable:n,composed:o,detail:s});return r};function isElementInViewport(e){let t=e.getBoundingClientRect(),s=window.innerHeight||document.documentElement.clientHeight,i=window.innerWidth||document.documentElement.clientWidth,n=t.top<=s&&t.top+t.height>0,o=t.left<=i&&t.left+t.width>0;return n&&o}function camelize(e){return e.replace(/(?:[_-])([a-z0-9])/g,(e,t)=>t.toUpperCase())}function __rest(e,t){var s={};for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&0>t.indexOf(i)&&(s[i]=e[i]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols)for(var n=0,i=Object.getOwnPropertySymbols(e);n<i.length;n++)0>t.indexOf(i[n])&&Object.prototype.propertyIsEnumerable.call(e,i[n])&&(s[i[n]]=e[i[n]]);return s}let defaultOptions$8={debug:!1,logger:console,dispatchEvent:!0,eventPrefix:!0};class StimulusUse{constructor(e,t={}){var s,i,n;this.log=(e,t)=>{this.debug&&(this.logger.groupCollapsed(`%c${this.controller.identifier} %c#${e}`,"color: #3B82F6","color: unset"),this.logger.log(Object.assign({controllerId:this.controllerId},t)),this.logger.groupEnd())},this.warn=e=>{this.logger.warn(`%c${this.controller.identifier} %c${e}`,"color: #3B82F6; font-weight: bold","color: unset")},this.dispatch=(e,t={})=>{if(this.dispatchEvent){let{event:s}=t,i=__rest(t,["event"]),n=this.extendedEvent(e,s||null,i);this.targetElement.dispatchEvent(n),this.log("dispatchEvent",Object.assign({eventName:n.type},i))}},this.call=(e,t={})=>{let s=this.controller[e];if("function"==typeof s)return s.call(this.controller,t)},this.extendedEvent=(e,t,s)=>{let{bubbles:i,cancelable:n,composed:o}=t||{bubbles:!0,cancelable:!0,composed:!0};t&&Object.assign(s,{originalEvent:t});let r=new CustomEvent(this.composeEventName(e),{bubbles:i,cancelable:n,composed:o,detail:s});return r},this.composeEventName=e=>{let t=e;return!0===this.eventPrefix?t=`${this.controller.identifier}:${e}`:"string"==typeof this.eventPrefix&&(t=`${this.eventPrefix}:${e}`),t},this.debug=null!==(i=null!==(s=null==t?void 0:t.debug)&&void 0!==s?s:e.application.stimulusUseDebug)&&void 0!==i?i:defaultOptions$8.debug,this.logger=null!==(n=null==t?void 0:t.logger)&&void 0!==n?n:defaultOptions$8.logger,this.controller=e,this.controllerId=e.element.id||e.element.dataset.id,this.targetElement=(null==t?void 0:t.element)||e.element;let{dispatchEvent:o,eventPrefix:r}=Object.assign({},defaultOptions$8,t);Object.assign(this,{dispatchEvent:o,eventPrefix:r}),this.controllerInitialize=e.initialize.bind(e),this.controllerConnect=e.connect.bind(e),this.controllerDisconnect=e.disconnect.bind(e)}}let defaultOptions$7={eventPrefix:!0,bubbles:!0,cancelable:!0};class UseDispatch extends StimulusUse{constructor(e,t={}){var s,i,n,o;super(e,t),this.dispatch=(e,t={})=>{let{controller:s,targetElement:i,eventPrefix:n,bubbles:o,cancelable:r,log:l,warn:a}=this;Object.assign(t,{controller:s});let c=composeEventName(e,this.controller,n),h=new CustomEvent(c,{detail:t,bubbles:o,cancelable:r});return i.dispatchEvent(h),a("`useDispatch()` is deprecated. Please use the built-in `this.dispatch()` function from Stimulus. You can find more information on how to upgrade at: https://stimulus-use.github.io/stimulus-use/#/use-dispatch"),l("dispatch",{eventName:c,detail:t,bubbles:o,cancelable:r}),h},this.targetElement=null!==(s=t.element)&&void 0!==s?s:e.element,this.eventPrefix=null!==(i=t.eventPrefix)&&void 0!==i?i:defaultOptions$7.eventPrefix,this.bubbles=null!==(n=t.bubbles)&&void 0!==n?n:defaultOptions$7.bubbles,this.cancelable=null!==(o=t.cancelable)&&void 0!==o?o:defaultOptions$7.cancelable,this.enhanceController()}enhanceController(){Object.assign(this.controller,{dispatch:this.dispatch})}}let useDispatch=(e,t={})=>new UseDispatch(e,t),defaultOptions$6={overwriteDispatch:!0},useApplication=(e,t={})=>{let{overwriteDispatch:s}=Object.assign({},defaultOptions$6,t);Object.defineProperty(e,"isPreview",{get:()=>document.documentElement.hasAttribute("data-turbolinks-preview")||document.documentElement.hasAttribute("data-turbo-preview")}),Object.defineProperty(e,"isConnected",{get(){return!!Array.from(this.context.module.connectedContexts).find(e=>e===this.context)}}),Object.defineProperty(e,"csrfToken",{get(){return this.metaValue("csrf-token")}}),s&&useDispatch(e,t),Object.assign(e,{metaValue(e){let t=document.head.querySelector(`meta[name="${e}"]`);return t&&t.getAttribute("content")}})};class ApplicationController extends e{constructor(e){super(e),this.isPreview=!1,this.isConnected=!1,this.csrfToken="",useApplication(this,this.options)}}let defaultOptions$5={events:["click","touchend"],onlyVisible:!0,dispatchEvent:!0,eventPrefix:!0},useClickOutside=(e,t={})=>{let s=e,{onlyVisible:i,dispatchEvent:n,events:o,eventPrefix:r}=Object.assign({},defaultOptions$5,t),l=e=>{let o=(null==t?void 0:t.element)||s.element;if(!o.contains(e.target)&&(isElementInViewport(o)||!i)&&(s.clickOutside&&s.clickOutside(e),n)){let l=composeEventName("click:outside",s,r),a=extendedEvent(l,e,{controller:s});o.dispatchEvent(a)}},a=()=>{null==o||o.forEach(e=>{window.addEventListener(e,l,!0)})},c=()=>{null==o||o.forEach(e=>{window.removeEventListener(e,l,!0)})},h=s.disconnect.bind(s);return Object.assign(s,{disconnect(){c(),h()}}),a(),[a,c]};class ClickOutsideComposableController extends e{}class ClickOutsideController extends ClickOutsideComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useClickOutside(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}class DebounceController extends e{}DebounceController.debounces=[];let defaultWait$1=200,debounce=(e,t=200)=>{let s=null;return function(){let i=Array.from(arguments),n=this,o=i.map(e=>e.params),r=()=>(i.forEach((e,t)=>e.params=o[t]),e.apply(n,i));s&&clearTimeout(s),s=setTimeout(r,t)}},useDebounce=(e,t)=>{let s=e,i=s.constructor;i.debounces.forEach(e=>{if("string"==typeof e&&(s[e]=debounce(s[e],null==t?void 0:t.wait)),"object"==typeof e){let{name:i,wait:n}=e;i&&(s[i]=debounce(s[i],n||(null==t?void 0:t.wait)))}})};class UseHover extends StimulusUse{constructor(e,t={}){super(e,t),this.observe=()=>{this.targetElement.addEventListener("mouseenter",this.onEnter),this.targetElement.addEventListener("mouseleave",this.onLeave)},this.unobserve=()=>{this.targetElement.removeEventListener("mouseenter",this.onEnter),this.targetElement.removeEventListener("mouseleave",this.onLeave)},this.onEnter=e=>{this.call("mouseEnter",e),this.log("mouseEnter",{hover:!0}),this.dispatch("mouseEnter",{hover:!1})},this.onLeave=e=>{this.call("mouseLeave",e),this.log("mouseLeave",{hover:!1}),this.dispatch("mouseLeave",{hover:!1})},this.controller=e,this.enhanceController(),this.observe()}enhanceController(){let e=this.controller.disconnect.bind(this.controller),t=()=>{this.unobserve(),e()};Object.assign(this.controller,{disconnect:t})}}let useHover=(e,t={})=>{let s=e,i=new UseHover(s,t);return[i.observe,i.unobserve]};class HoverComposableController extends e{}class HoverController extends HoverComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useHover(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}let defaultEvents=["mousemove","mousedown","resize","keydown","touchstart","wheel"],oneMinute=6e4,defaultOptions$4={ms:6e4,initialState:!1,events:defaultEvents,dispatchEvent:!0,eventPrefix:!0},useIdle=(e,t={})=>{let s=e,{ms:i,initialState:n,events:o,dispatchEvent:r,eventPrefix:l}=Object.assign({},defaultOptions$4,t),a=n,c=setTimeout(()=>{a=!0,h()},i),h=e=>{let t=composeEventName("away",s,l);if(s.isIdle=!0,method(s,"away").call(s,e),r){let i=extendedEvent(t,e||null,{controller:s});s.element.dispatchEvent(i)}},u=e=>{let t=composeEventName("back",s,l);if(s.isIdle=!1,method(s,"back").call(s,e),r){let i=extendedEvent(t,e||null,{controller:s});s.element.dispatchEvent(i)}},d=e=>{a&&u(e),a=!1,clearTimeout(c),c=setTimeout(()=>{a=!0,h(e)},i)},m=e=>{document.hidden||d(e)};a?h():u();let p=s.disconnect.bind(s),v=()=>{o.forEach(e=>{window.addEventListener(e,d)}),document.addEventListener("visibilitychange",m)},g=()=>{clearTimeout(c),o.forEach(e=>{window.removeEventListener(e,d)}),document.removeEventListener("visibilitychange",m)};return Object.assign(s,{disconnect(){g(),p()}}),v(),[v,g]};class IdleComposableController extends e{constructor(){super(...arguments),this.isIdle=!1}}class IdleController extends IdleComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useIdle(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}let defaultOptions$3={dispatchEvent:!0,eventPrefix:!0,visibleAttribute:"isVisible"},useIntersection=(e,t={})=>{let s=e,{dispatchEvent:i,eventPrefix:n,visibleAttribute:o}=Object.assign({},defaultOptions$3,t),r=(null==t?void 0:t.element)||s.element;s.intersectionElements||(s.intersectionElements=[]),s.intersectionElements.push(r);let l=e=>{let[t]=e;t.isIntersecting?a(t):r.hasAttribute(o)&&c(t)},a=e=>{if(r.setAttribute(o,"true"),method(s,"appear").call(s,e),i){let t=composeEventName("appear",s,n),l=extendedEvent(t,null,{controller:s,entry:e});r.dispatchEvent(l)}},c=e=>{if(r.removeAttribute(o),method(s,"disappear").call(s,e),i){let t=composeEventName("disappear",s,n),l=extendedEvent(t,null,{controller:s,entry:e});r.dispatchEvent(l)}},h=s.disconnect.bind(s),u=new IntersectionObserver(l,t),d=()=>{u.observe(r)},m=()=>{u.unobserve(r)},p=()=>s.intersectionElements.some(e=>e.hasAttribute(o)),v=()=>s.intersectionElements.every(e=>e.hasAttribute(o)),g=v;return Object.assign(s,{isVisible:g,noneVisible:()=>0===s.intersectionElements.filter(e=>e.hasAttribute(o)).length,oneVisible:()=>1===s.intersectionElements.filter(e=>e.hasAttribute(o)).length,atLeastOneVisible:p,allVisible:v,disconnect(){m(),h()}}),d(),[d,m]};class IntersectionComposableController extends e{}class IntersectionController extends IntersectionComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useIntersection(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}let useLazyLoad=(e,t)=>{let s=t=>{let[s]=t;s.isIntersecting&&!e.isLoaded&&i()},i=t=>{let s=e.data.get("src");if(!s)return;let i=e.element;e.isLoading=!0,method(e,"loading").call(e,s),i.onload=()=>{n(s)},i.src=s},n=t=>{e.isLoading=!1,e.isLoaded=!0,method(e,"loaded").call(e,t)},o=e.disconnect.bind(e),r=new IntersectionObserver(s,t),l=()=>{r.observe(e.element)},a=()=>{r.unobserve(e.element)};return Object.assign(e,{isVisible:!1,disconnect(){a(),o()}}),l(),[l,a]};class LazyLoadComposableController extends e{constructor(){super(...arguments),this.isLoading=!1,this.isLoaded=!1}}class LazyLoadController extends LazyLoadComposableController{constructor(e){super(e),this.options={rootMargin:"10%"},requestAnimationFrame(()=>{let[e,t]=useLazyLoad(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}let defaultOptions$2={mediaQueries:{},dispatchEvent:!0,eventPrefix:!0,debug:!1};class UseMatchMedia extends StimulusUse{constructor(e,t={}){var s,i,n,o;if(super(e,t),this.matches=[],this.callback=e=>{let t=Object.keys(this.mediaQueries).find(t=>this.mediaQueries[t]===e.media);if(!t)return;let{media:s,matches:i}=e;this.changed({name:t,media:s,matches:i,event:e})},this.changed=e=>{let{name:t}=e;e.event&&(this.call(camelize(`${t}_changed`),e),this.dispatch(`${t}:changed`,e),this.log(`media query "${t}" changed`,e)),e.matches?(this.call(camelize(`is_${t}`),e),this.dispatch(`is:${t}`,e)):(this.call(camelize(`not_${t}`),e),this.dispatch(`not:${t}`,e))},this.observe=()=>{Object.keys(this.mediaQueries).forEach(e=>{let t=this.mediaQueries[e],s=window.matchMedia(t);s.addListener(this.callback),this.matches.push(s),this.changed({name:e,media:t,matches:s.matches})})},this.unobserve=()=>{this.matches.forEach(e=>e.removeListener(this.callback))},this.controller=e,this.mediaQueries=null!==(s=t.mediaQueries)&&void 0!==s?s:defaultOptions$2.mediaQueries,this.dispatchEvent=null!==(i=t.dispatchEvent)&&void 0!==i?i:defaultOptions$2.dispatchEvent,this.eventPrefix=null!==(n=t.eventPrefix)&&void 0!==n?n:defaultOptions$2.eventPrefix,this.debug=null!==(o=t.debug)&&void 0!==o?o:defaultOptions$2.debug,!window.matchMedia){console.error("window.matchMedia() is not available");return}this.enhanceController(),this.observe()}enhanceController(){let e=this.controller.disconnect.bind(this.controller),t=()=>{this.unobserve(),e()};Object.assign(this.controller,{disconnect:t})}}let useMatchMedia=(e,t={})=>{let s=new UseMatchMedia(e,t);return[s.observe,s.unobserve]},memoize=(e,t,s)=>(Object.defineProperty(e,t,{value:s}),s),useMemo=e=>{var t;null===(t=e.constructor.memos)||void 0===t||t.forEach(t=>{memoize(e,t,e[t])})},defineMetaGetter=(e,t,s)=>{let i=s?`${camelize(t)}Meta`:camelize(t);Object.defineProperty(e,i,{get:()=>typeCast(metaValue(t))})};function metaValue(e){let t=document.head.querySelector(`meta[name="${e}"]`);return t&&t.getAttribute("content")}function typeCast(e){try{return JSON.parse(e)}catch(t){return e}}let useMeta=(e,t={suffix:!0})=>{let s=e.constructor.metaNames,i=t.suffix;null==s||s.forEach(t=>{defineMetaGetter(e,t,i)}),Object.defineProperty(e,"metas",{get(){let e={};return null==s||s.forEach(t=>{let s=typeCast(metaValue(t));null!=s&&(e[camelize(t)]=s)}),e}})};class UseMutation extends StimulusUse{constructor(e,t={}){super(e,t),this.observe=()=>{try{this.observer.observe(this.targetElement,this.options)}catch(e){this.controller.application.handleError(e,"At a minimum, one of childList, attributes, and/or characterData must be true",{})}},this.unobserve=()=>{this.observer.disconnect()},this.mutation=e=>{this.call("mutate",e),this.log("mutate",{entries:e}),this.dispatch("mutate",{entries:e})},this.targetElement=(null==t?void 0:t.element)||e.element,this.controller=e,this.options=t,this.observer=new MutationObserver(this.mutation),this.enhanceController(),this.observe()}enhanceController(){let e=this.controller.disconnect.bind(this.controller),t=()=>{this.unobserve(),e()};Object.assign(this.controller,{disconnect:t})}}let useMutation=(e,t={})=>{let s=new UseMutation(e,t);return[s.observe,s.unobserve]};class MutationComposableController extends e{}class MutationController extends MutationComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useMutation(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}let defaultOptions$1={dispatchEvent:!0,eventPrefix:!0},useResize=(e,t={})=>{let s=e,{dispatchEvent:i,eventPrefix:n}=Object.assign({},defaultOptions$1,t),o=(null==t?void 0:t.element)||s.element,r=e=>{let[t]=e;if(method(s,"resize").call(s,t.contentRect),i){let r=composeEventName("resize",s,n),l=extendedEvent(r,null,{controller:s,entry:t});o.dispatchEvent(l)}},l=s.disconnect.bind(s),a=new ResizeObserver(r),c=()=>{a.observe(o)},h=()=>{a.unobserve(o)};return Object.assign(s,{disconnect(){h(),l()}}),c(),[c,h]};class ResizeComposableController extends e{}class ResizeController extends ResizeComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useResize(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}class UseTargetMutation extends StimulusUse{constructor(e,t={}){super(e,t),this.observe=()=>{this.observer.observe(this.targetElement,{subtree:!0,characterData:!0,childList:!0,attributes:!0,attributeOldValue:!0,attributeFilter:[this.targetSelector,this.scopedTargetSelector]})},this.unobserve=()=>{this.observer.disconnect()},this.mutation=e=>{for(let t of e)switch(t.type){case"attributes":let s=t.target.getAttribute(t.attributeName),i=t.oldValue;if(t.attributeName===this.targetSelector||t.attributeName===this.scopedTargetSelector){let n=this.targetsUsedByThisController(i),o=this.targetsUsedByThisController(s),r=n.filter(e=>!o.includes(e)),l=o.filter(e=>!n.includes(e));r.forEach(e=>this.targetRemoved(this.stripIdentifierPrefix(e),t.target,"attributeChange")),l.forEach(e=>this.targetAdded(this.stripIdentifierPrefix(e),t.target,"attributeChange"))}break;case"characterData":let a=this.findTargetInAncestry(t.target);if(null==a)return;this.targetsUsedByThisControllerFromNode(a).forEach(e=>{this.targetChanged(this.stripIdentifierPrefix(e),a,"domMutation")});break;case"childList":let{addedNodes:c,removedNodes:h}=t;c.forEach(e=>this.processNodeDOMMutation(e,this.targetAdded)),h.forEach(e=>this.processNodeDOMMutation(e,this.targetRemoved))}},this.controller=e,this.options=t,this.targetElement=e.element,this.identifier=e.scope.identifier,this.identifierPrefix=`${this.identifier}.`,this.targetSelector=e.scope.schema.targetAttribute,this.scopedTargetSelector=`data-${this.identifier}-target`,this.targets=t.targets||e.constructor.targets,this.prefixedTargets=this.targets.map(e=>`${this.identifierPrefix}${e}`),this.observer=new MutationObserver(this.mutation),this.enhanceController(),this.observe()}processNodeDOMMutation(e,t){let s=e,i=t,n=[];"#text"==s.nodeName||0==this.targetsUsedByThisControllerFromNode(s).length?(i=this.targetChanged,s=this.findTargetInAncestry(e)):n=this.targetsUsedByThisControllerFromNode(s),null!=s&&(0==n.length&&(n=this.targetsUsedByThisControllerFromNode(s)),n.forEach(e=>{i.call(this,this.stripIdentifierPrefix(e),s,"domMutation")}))}findTargetInAncestry(e){let t=e,s=[];for("#text"!=t.nodeName&&(s=this.targetsUsedByThisControllerFromNode(t));null!==t.parentNode&&t.parentNode!=this.targetElement&&0==s.length;)if("#text"!==(t=t.parentNode).nodeName&&this.targetsUsedByThisControllerFromNode(t).length>0)return t;return"#text"==t.nodeName||null==t.parentNode?null:t.parentNode==this.targetElement&&this.targetsUsedByThisControllerFromNode(t).length>0?t:null}targetAdded(e,t,s){let i=`${e}TargetAdded`;this.controller[i]&&method(this.controller,i).call(this.controller,t),this.log("targetAdded",{target:e,node:t,trigger:s})}targetRemoved(e,t,s){let i=`${e}TargetRemoved`;this.controller[i]&&method(this.controller,i).call(this.controller,t),this.log("targetRemoved",{target:e,node:t,trigger:s})}targetChanged(e,t,s){let i=`${e}TargetChanged`;this.controller[i]&&method(this.controller,i).call(this.controller,t),this.log("targetChanged",{target:e,node:t,trigger:s})}targetsUsedByThisControllerFromNode(e){if("#text"==e.nodeName||"#comment"==e.nodeName)return[];let t=e;return this.targetsUsedByThisController(t.getAttribute(this.scopedTargetSelector)||t.getAttribute(this.targetSelector))}targetsUsedByThisController(e){e=e||"";let t=this.stripIdentifierPrefix(e).split(" ");return this.targets.filter(e=>-1!==t.indexOf(e))}stripIdentifierPrefix(e){return e.replace(RegExp(this.identifierPrefix,"g"),"")}enhanceController(){let e=this.controller.disconnect.bind(this.controller),t=()=>{this.unobserve(),e()};Object.assign(this.controller,{disconnect:t})}}let useTargetMutation=(e,t={})=>{let s=e,i=new UseTargetMutation(s,t);return[i.observe,i.unobserve]};class TargetMutationComposableController extends e{}class TargetMutationController extends TargetMutationComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useTargetMutation(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}class ThrottleController extends e{}ThrottleController.throttles=[];let defaultWait=200;function throttle(e,t=200){let s;return function(){let i=arguments;s||(s=!0,e.apply(this,i),setTimeout(()=>s=!1,t))}}let useThrottle=(e,t={})=>{var s;let i=e,n=i.constructor;null===(s=n.throttles)||void 0===s||s.forEach(e=>{if("string"==typeof e&&(i[e]=throttle(i[e],null==t?void 0:t.wait)),"object"==typeof e){let{name:s,wait:n}=e;s&&(i[s]=throttle(i[s],n||(null==t?void 0:t.wait)))}})},alpineNames={enterFromClass:"enter",enterActiveClass:"enterStart",enterToClass:"enterEnd",leaveFromClass:"leave",leaveActiveClass:"leaveStart",leaveToClass:"leaveEnd"},defaultOptions={transitioned:!1,hiddenClass:"hidden",preserveOriginalClass:!0,removeToClasses:!0},useTransition=(e,t={})=>{var s,i,n;let o=e,r=o.element.dataset.transitionTarget,l;r&&(l=o[`${r}Target`]);let a=(null==t?void 0:t.element)||l||o.element;if(!(a instanceof HTMLElement||a instanceof SVGElement))return;let c=a.dataset,h=parseInt(c.leaveAfter||"")||t.leaveAfter||0,{transitioned:u,hiddenClass:d,preserveOriginalClass:m,removeToClasses:p}=Object.assign({},defaultOptions,t),v=null===(s=o.enter)||void 0===s?void 0:s.bind(o),g=null===(i=o.leave)||void 0===i?void 0:i.bind(o),b=null===(n=o.toggleTransition)||void 0===n?void 0:n.bind(o);async function f(e){if(o.transitioned)return;o.transitioned=!0,v&&v(e);let s=getAttribute("enterFrom",t,c),i=getAttribute("enterActive",t,c),n=getAttribute("enterTo",t,c),r=getAttribute("leaveTo",t,c);d&&a.classList.remove(d),p||w(a,r),await E(a,s,i,n,d,m,p),h>0&&setTimeout(()=>{C(e)},h)}async function C(e){if(!o.transitioned)return;o.transitioned=!1,g&&g(e);let s=getAttribute("leaveFrom",t,c),i=getAttribute("leaveActive",t,c),n=getAttribute("leaveTo",t,c),r=getAttribute("enterTo",t,c);p||w(a,r),await E(a,s,i,n,d,m,p),d&&a.classList.add(d)}function $(e){b&&b(e),o.transitioned?C():f()}async function E(e,t,s,i,n,o,r){let l=[];o&&(t.forEach(t=>e.classList.contains(t)&&t!==n&&l.push(t)),s.forEach(t=>e.classList.contains(t)&&t!==n&&l.push(t)),i.forEach(t=>e.classList.contains(t)&&t!==n&&l.push(t))),x(e,t),w(e,l),x(e,s),await nextAnimationFrame(),w(e,t),x(e,i),await afterTransition(e),w(e,s),r&&w(e,i),x(e,l)}function y(){o.transitioned=u,u?(d&&a.classList.remove(d),f()):(d&&a.classList.add(d),C())}function x(e,t){t.length>0&&e.classList.add(...t)}function w(e,t){t.length>0&&e.classList.remove(...t)}return y(),Object.assign(o,{enter:f,leave:C,toggleTransition:$}),[f,C,$]};function getAttribute(e,t,s){let i=`transition${e[0].toUpperCase()}${e.substr(1)}`,n=alpineNames[e],o=t[e]||s[i]||s[n]||" ";return isEmpty(o)?[]:o.split(" ")}async function afterTransition(e){return new Promise(t=>{let s=1e3*Number(getComputedStyle(e).transitionDuration.split(",")[0].replace("s",""));setTimeout(()=>{t(s)},s)})}async function nextAnimationFrame(){return new Promise(e=>{requestAnimationFrame(()=>{requestAnimationFrame(e)})})}function isEmpty(e){return 0===e.length||!e.trim()}class TransitionComposableController extends e{constructor(){super(...arguments),this.transitioned=!1}}class TransitionController extends TransitionComposableController{constructor(e){super(e),requestAnimationFrame(()=>{useTransition(this,this.options)})}}class UseVisibility extends StimulusUse{constructor(e,t={}){super(e,t),this.observe=()=>{this.controller.isVisible=!document.hidden,document.addEventListener("visibilitychange",this.handleVisibilityChange),this.handleVisibilityChange()},this.unobserve=()=>{document.removeEventListener("visibilitychange",this.handleVisibilityChange)},this.becomesInvisible=e=>{this.controller.isVisible=!1,this.call("invisible",e),this.log("invisible",{isVisible:!1}),this.dispatch("invisible",{event:e,isVisible:!1})},this.becomesVisible=e=>{this.controller.isVisible=!0,this.call("visible",e),this.log("visible",{isVisible:!0}),this.dispatch("visible",{event:e,isVisible:!0})},this.handleVisibilityChange=e=>{document.hidden?this.becomesInvisible(e):this.becomesVisible(e)},this.controller=e,this.enhanceController(),this.observe()}enhanceController(){let e=this.controllerDisconnect,t=()=>{this.unobserve(),e()};Object.assign(this.controller,{disconnect:t})}}let useVisibility=(e,t={})=>{let s=e,i=new UseVisibility(s,t);return[i.observe,i.unobserve]};class VisibilityComposableController extends e{constructor(){super(...arguments),this.isVisible=!1}}class VisibilityController extends VisibilityComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useVisibility(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}class UseWindowFocus extends StimulusUse{constructor(e,t={}){super(e,t),this.observe=()=>{document.hasFocus()?this.becomesFocused():this.becomesUnfocused(),this.interval=setInterval(()=>{this.handleWindowFocusChange()},this.intervalDuration)},this.unobserve=()=>{clearInterval(this.interval)},this.becomesUnfocused=e=>{this.controller.hasFocus=!1,this.call("unfocus",e),this.log("unfocus",{hasFocus:!1}),this.dispatch("unfocus",{event:e,hasFocus:!1})},this.becomesFocused=e=>{this.controller.hasFocus=!0,this.call("focus",e),this.log("focus",{hasFocus:!0}),this.dispatch("focus",{event:e,hasFocus:!0})},this.handleWindowFocusChange=e=>{document.hasFocus()&&!this.controller.hasFocus?this.becomesFocused(e):!document.hasFocus()&&this.controller.hasFocus&&this.becomesUnfocused(e)},this.controller=e,this.intervalDuration=t.interval||200,this.enhanceController(),this.observe()}enhanceController(){let e=this.controllerDisconnect,t=()=>{this.unobserve(),e()};Object.assign(this.controller,{disconnect:t})}}let useWindowFocus=(e,t={})=>{let s=e,i=new UseWindowFocus(s,t);return[i.observe,i.unobserve]};class WindowFocusComposableController extends e{constructor(){super(...arguments),this.hasFocus=!1}}class WindowFocusController extends WindowFocusComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useWindowFocus(this,this.options);Object.assign(this,{observe:e,unobserve:t})})}}let useWindowResize=e=>{let t=e,s=e=>{let{innerWidth:s,innerHeight:i}=window,n={height:i||1/0,width:s||1/0,event:e};method(t,"windowResize").call(t,n)},i=t.disconnect.bind(t),n=()=>{window.addEventListener("resize",s),s()},o=()=>{window.removeEventListener("resize",s)};return Object.assign(t,{disconnect(){o(),i()}}),n(),[n,o]};class WindowResizeComposableController extends e{}class WindowResizeController extends WindowResizeComposableController{constructor(e){super(e),requestAnimationFrame(()=>{let[e,t]=useWindowResize(this);Object.assign(this,{observe:e,unobserve:t})})}}function useHotkeys(){throw"[stimulus-use] Notice: The import for `useHotkeys()` has been moved from `stimulus-use` to `stimulus-use/hotkeys`. \nPlease change the import accordingly and add `hotkey-js` as a dependency to your project. \n\nFor more information see: https://stimulus-use.github.io/stimulus-use/#/use-hotkeys?id=importing-the-behavior"}export{ApplicationController,ClickOutsideController,HoverController,IdleController,IntersectionController,LazyLoadController,MutationController,ResizeController,TargetMutationController,TransitionController,UseHover,UseMutation,UseTargetMutation,UseVisibility,UseWindowFocus,VisibilityController,WindowFocusController,WindowResizeController,debounce,useApplication,useClickOutside,useDebounce,useDispatch,useHotkeys,useHover,useIdle,useIntersection,useLazyLoad,useMatchMedia,useMemo,useMeta,useMutation,useResize,useTargetMutation,useThrottle,useTransition,useVisibility,useWindowFocus,useWindowResize};
